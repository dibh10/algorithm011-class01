学习笔记

lesson 3
array    在知道索引情况下，查找O(1)，不知道索引情况查找O(n); 不在末尾进行添加删除操作都是O(n);
list     查找O(n)，添加、删除操作为O(1)，但是添加和删除都是以查找为前提的，所以综合复杂度也为O(n);
skiplist 查找、添加、删除操作为O(logn); 空间复杂度由于收敛计算后仍然为O(n)，但是比原始链表空间复杂度还是高的多；且频繁增加删除操作会导致索引不工整，维护成本较高.
         跳表是使用了升维的思想，使用空间复杂度去换取时间复杂度。

如果数据范围确定，可以优先使用array；
如果数据范围不确定，且伴随较多的插入和删除操作，可以优先使用list.

lesson 4
Stack：先进后出(FILO)；添加、删除皆为O(1);查询O(n)
Queue：先进先出(FIFO)；添加、删除皆为O(1);查询O(n)

Deque：队首、队尾都可以进行添加和删除操作；添加、删除皆为O(1);查询O(n)

使用何种线性数据结构来解决问题也是来源于生活
Stack 使用场景具有最近相关性（leetcode 20.valid-parentheses）
Queue 使用场景类似于排队，遵循先来后到原则